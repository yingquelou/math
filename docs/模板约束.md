#

C++中的模板约束（template constraints）是 C++20 引入的新功能，用于限制模板参数的类型或属性。以下是一些常见的模板约束用法：

1. 类型约束：使用关键字"requires"后跟一个类型作为模板参数限制它的类型。

```c++
template<typename T>
requires std::is_integral_v<T>
class MyIntegerClass {
    // ...
};
```

2. 表达式约束：使用关键字"requires"后跟一个表达式，可以依据条件来限制模板参数。

```c++
template<typename T>
requires (sizeof(T) > 4)
void DoSomething(T value) {
    // ...
}
```

3. 概念约束：使用关键字"requires"后跟一个概念(concept)，表示模板参数必须符合该概念所定义的要求。

```c++
template<typename T>
requires std::ranges::range<T>
void DoSomething(T& container) {
    // ...
}
```

4. 函数签名约束：使用关键字"requires"后跟一个函数签名，表示模板参数必须有与该签名匹配的成员函数。

```c++
template<typename T>
requires requires(T t) {
    { t.foo() } -> std::same_as<void>; // 必须有 void foo() 成员函数
    { t.bar() } -> std::convertible_to<int>; // 必须有 int bar() 成员函数
}
void DoSomething(T& obj) {
    obj.foo();
    int n = obj.bar();
}
```

5. AND/OR/NOT 约束：使用逻辑运算符"&&"、"||"和"!"来组合多个约束条件。

```c++
template<typename T>
requires std::is_integral_v<T> && (sizeof(T) > 2)
class MyIntegerClass {
    // ...
};

template<typename T>
requires std::ranges::range<T> || std::is_pointer_v<T>
void DoSomething(T& container) {
    // ...
}

template<typename T>
requires !std::is_pointer_v<T>
void DoSomethingElse(T& obj) {
    // ...
}
```

这些是常见的模板约束用法，C++20 还提供了其他一些高级功能，如 requires 分离和 requires expressions 等。需要注意的是，模板约束是 C++20 新功能，可能不受所有编译器的支持，也可能在未来版本中进行修改或扩展。
