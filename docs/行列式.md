# 行列式

## 设计要求

请根据行列式的性质设计一个 c++模板类,并满足以下要求

1. 代码需要注释
2. 尽可能支持行列式的所有运算
3. 使用 concept、requires 对模板参数进行限制,要求行列式元素类型只能是实数或复数
4. 对二维及以上的维度的行列式依旧适用
   注意: 只需要接口规范,不需要具体实现

## 示例 1

以下是一个基于 C++模板类的行列式类的接口设计，满足以下要求：

1. 代码需要注释
2. 尽可能支持行列式的所有运算
3. 使用 concept、requires 对模板参数进行限制，要求行列式元素类型只能是实数或复数
4. 对二维及以上的维度的行列式依旧适用

````cpp
#include <type_traits>
#include <concepts>

// 定义一个模板类L，表示行列式
template <typename T, std::size_t N>
class L {
    static_assert(std::is_arithmetic_v<T> || std::is_same_v<T, std::complex<typename T::value_type>>, "T must be a numeric type or a complex type with a numeric value type");

public:
    using value_type = T;
    static constexpr std::size_t order = N;

    // 构造函数
    L() noexcept = default;
    L(const L&) noexcept = default;
    L(L&&) noexcept = default;
    ~L() noexcept = default;
    L& operator=(const L&) noexcept = default;
    L& operator=(L&&) noexcept = default;

    // 获取行列式中指定元素的值
    template <std::size_t... Is>
    requires (sizeof...(Is) == N && ((Is >= 0 && Is < N) && ...))
    [[nodiscard]] constexpr value_type get_element() const noexcept;

    // 调换行列式中指定两行或两列
    template <std::size_t I, std::size_t J>
    requires ((I >= 0 && I < N) && (J >= 0 && J < N))
    constexpr void swap_rows() noexcept;
    template <std::size_t I, std::size_t J>
    requires ((I >= 0 && I < N) && (J >= 0 && J < N))
    constexpr void swap_columns() noexcept;

    // 行列式的基本性质
    [[nodiscard]] constexpr value_type determinant() const noexcept;
    [[nodiscard]] constexpr L inverse() const noexcept;
    [[nodiscard]] constexpr L transpose() const noexcept;

    // 行列式与数的乘除法以及加减运算
    template <typename U>
    requires std::is_arithmetic_v<U>
    [[nodiscard]] constexpr L operator*(const U& scalar) const noexcept;
    template <typename U>
    requires std::is_arithmetic_v<U>
    [[nodiscard]] constexpr friend L operator*(const U& scalar, const L& m) noexcept {
        return m * scalar;
    }
    template <typename U>
    requires std::is_arithmetic_v<U>
    constexpr L& operator*=(const U& scalar) noexcept;
    template <typename U>
    requires std::is_arithmetic_v<U>
    [[nodiscard]] constexpr L operator/(const U& scalar) const noexcept;
    template <typename U>
    requires std::is_arithmetic_v<U>
    constexpr L& operator/=(const U& scalar) noexcept;
    [[nodiscard]] constexpr L operator+(const L& other) const noexcept;
    constexpr L& operator+=(const L& other) noexcept;
    [[nodiscard]] constexpr L operator-(const L& other) const noexcept;
    constexpr L& operator-=(const L& other) noexcept;

    // 行列式与向量、矩阵的乘法
    template <typename U>
    requires (std::is_arithmetic_v<U> || std::is_same_v<U, std::complex<typename U::value_type>>)
    [[nodiscard]] constexpr decltype(auto) operator*(const std::array<U, N>& v) const noexcept;
    template <typename U, std::size_t M>
    requires (std::is_same_v<U, L<typename U::value_type, M>> && M == N)
    [[nodiscard]] constexpr decltype(auto) operator*(const U& m) const noexcept;

    // 比较运算符
    [[nodiscard]] bool operator==(const L& other) const noexcept;
    [[nodiscard]] bool operator!=(const L& other) const noexcept;
};

// 获取行列式中指定元素的值
template <typename T, std::size_t N>
template <std::size_t... Is>
requires (sizeof...(Is) == N && ((Is >= 0 && Is < N) && ...))
[[nodiscard]] constexpr typename L<T, N>::value_type L<T, N>::get_element() const noexcept {
    // 实现
    ```
````
