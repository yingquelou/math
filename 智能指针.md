`shared_ptr`和`unique_ptr`都支持的操作|解释说明
|:-:|:-|
`shared_ptr<T> sp`| 空智能指针，可以指向类型为`T`的对象 
`unique_ptr<T> up`|
`p`|将`p`用作一个条件判断，若`p`指向一个对象，则为`true`
`*p`|解引用`p`，获得它指向的对象
`p->mem` |等价于`(*p).mem` 
`p.get() `|返回`p`中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了
`swap(p,q)` |交换`p`和`q`中的指针 
`p.swap(q)`|

---

`shared_ptr`独有的操作|解释说明
|:-:|:-|
`make_shared<T>(args)` |返回一个`shared_ptr`，指向一个动态分配的类型为T的对象。使用`args`初始化此对象
`make_shared<T>p(q)`| `p`是`shared_ptrq`的拷贝;此操作会递增`q`中的计数器。`q`中的指针必须能转换为`T*`
`p=q` |`p`和`q`都是`shared_ptr`，所保存的指针必须能相互转换。此操作会递减`p`的引用计数，递增`q`的引用计数;若`p`的引用计数变为`0`，则将其管理的原内存释放
`p.unique()` |若`p.use_count()`为`1`，返回`true`;否则返回`false` 
`p.use_count()` |返回与`p`共享对象的智能指针数量;可能很慢,主要用于调试

定义和改变`shared_ptr`的其他方法|解释说明
|:-:|:-|
`shared_ptr<T> p(q)`|`p`管理内置指针`q`所指向的对象;`q`必须指向`new`分配的内存，且能够转换为`T*`类型
`shared_ptr<T> p(u)`| `p`从`unique_ptr u`那里接管了对象的所有权;将`u`置为空 
`shared_ptr<T> p(q,d)`| `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete`
`shared_ptr<T> p(p2.d)` |`p`是`shared_ptr p2`的拷贝，唯一的区别是`p`将用可调用对象`d`来代替`delete`
`p.reset()` |若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会 将`p`置为空。若还传递了参数`d`，将会调用`d`而不是`delete`来释放`q`
`p.reset(q)`|
`p.reset(q,d)`|

---

`unique_ptr`操作|解释说明
|:-:|:-|
`unique_ptr<T> u1` |空`unique_ptr`,可以指向类型为`T`的对象。`u1`会使用`delete`来释放它的指针;
`unique_ptr<T,D> u2`|`u2`会使用一个类型为`D`的可调用对象来释放它的指针
`unique_ptr<T,D> u(d)` |空`unique_ptr`，指向类型为`T`的对象，用类型为`D`的对象`d`代替`delete`
`u=nullptr` |释放`u`指向的对象，将`u`置为空 
`u.release()`| `u`放弃对指针的控制权，返回指针，并将`u`置为空 
`u.reset()` |释放`u`指向的对象 
`u.reset(q)` |如果提供了内置指针`q`，令`u`指向这个对象;否则将`u`置为空 
`u.reset(nullptr)`|

---

`weak_ptr`|解释说明
|:-:|:-|
`weak_ptr<T> W` |空`weak_ptr`可以指向类型为T的对象 
`weak_ptr<T> w(sp)` |与`shared_ptr sp`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型
`w=p` |`p`可以是一个`shared_ptr`或一个`weak_ptr`.赋值后`w`与`p`共享对象
`w.reset()` |将`w`置为空 
`w.use_count()`| 与`w`共享对象的`shared_ptr`的数量 
`w.expired()` |若`w.use_count()`为`0`，返回`true`，否则返回`false` 
`w.lock()`| 如果`expired`为`true`，返回一个空`shared_ptr`;否则返回一个指向`w`的对象的`shared_ptr`