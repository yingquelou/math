`shared_ptr`和`unique_ptr`都支持的操作|解释说明
|:-:|:-|
`shared_ptr<T> sp`| 空智能指针，可以指向类型为`T`的对象 
`unique_ptr<T> up`|
`p`|将`p`用作一个条件判断，若`p`指向一个对象，则为`true`
`*p`|解引用`p`，获得它指向的对象
`p->mem` |等价于`(*p).mem` 
`p.get() `|返回`p`中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了
`swap(p,q)` |交换`p`和`q`中的指针 
`p.swap(q)`|

---

`shared_ptr`独有的操作|解释说明
|:-:|:-|
`make_shared<T>(args)` |返回一个`shared_ptr`，指向一个动态分配的类型为T的对象。使用`args`初始化此对象
`make_shared<T>p(q)`| `p`是`shared_ptr q`的拷贝;此操作会递增`q`中的计数器。`q`中的指针必须能转换为`T*`
`p=q` |`p`和`q`都是`shared_ptr`，所保存的指针必须能相互转换。此操作会递减`p`的引用计数，递增`q`的引用计数;若`p`的引用计数变为`0`，则将其管理的原内存释放
`p.unique()` |若`p.use_count()`为`1`，返回`true`;否则返回`false` 
`p.use_count()` |返回与`p`共享对象的智能指针数量;可能很慢,主要用于调试

定义和改变`shared_ptr`的其他方法|解释说明
|:-:|:-|
`shared_ptr<T> p(q)`|`p`管理内置指针`q`所指向的对象;`q`必须指向`new`分配的内存，且能够转换为`T*`类型
`shared_ptr<T> p(u)`| `p`从`unique_ptr u`那里接管了对象的所有权;将`u`置为空 
`shared_ptr<T> p(q,d)`| `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete`
`shared_ptr<T> p(p2.d)` |`p`是`shared_ptr p2`的拷贝，唯一的区别是`p`将用可调用对象`d`来代替`delete`
`p.reset()` |若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会 将`p`置为空。若还传递了参数`d`，将会调用`d`而不是`delete`来释放`q`
`p.reset(q)`|
`p.reset(q,d)`|

---

`unique_ptr`操作|解释说明
|:-:|:-|
`unique_ptr<T> u1` |空`unique_ptr`,可以指向类型为`T`的对象。`u1`会使用`delete`来释放它的指针;
`unique_ptr<T,D> u2`|`u2`会使用一个类型为`D`的可调用对象来释放它的指针
`unique_ptr<T,D> u(d)` |空`unique_ptr`，指向类型为`T`的对象，用类型为`D`的对象`d`代替`delete`
`u=nullptr` |释放`u`指向的对象，将`u`置为空 
`u.release()`| `u`放弃对指针的控制权，返回指针，并将`u`置为空 
`u.reset()` |释放`u`指向的对象 
`u.reset(q)` |如果提供了内置指针`q`，令`u`指向这个对象;否则将`u`置为空 
`u.reset(nullptr)`|

---
指向数组的`unique_ptr`|解释说明
|:-:|:-|
`unique_ptr<T[]> u`| `u`可以指向一个动态分配的数组，数组元素类型为`T` 
`unique_ptr<T[]> u(p)`| `u`指向内置指针`p`所指向的动态分配的数组。`p`必须能转换为类型`T*`
`u[i]` |返回`u`拥有的数组中位置i处的对象。`u`必须指向一个数组
```
指向数组的`unique_ptr`不支持成员访问运算符(点和箭头运算符)。其他`unique_ptr`操作不变。
```
---

`weak_ptr`|解释说明
|:-:|:-|
`weak_ptr<T> w` |空`weak_ptr`可以指向类型为`T`的对象 
`weak_ptr<T> w(sp)` |与`shared_ptr sp`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型
`w=p` |`p`可以是一个`shared_ptr`或一个`weak_ptr`.赋值后`w`与`p`共享对象
`w.reset()` |将`w`置为空
`w.use_count()`| 与`w`共享对象的`shared_ptr`的数量 
`w.expired()` |若`w.use_count()`为`0`，返回`true`，否则返回`false` 
`w.lock()`| 如果`expired`为`true`，返回一个空`shared_ptr`;否则返回一个指向`w`的对象的`shared_ptr`
---
标准库`allocator`类及其算法|解释说明
|:-:|:-|
`allocator<T> a`| 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存
`a.allocate(n)`| 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象 
`a.deallocate(p,n)`|释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象;`p`必须是一个先前由`allocate`返回的指针，且`n`必须是`p`创建时所要求的大小。在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy`
`a.construct(p,args)` |`p`必须是一个类型为`T`的指针，指向一块原始内存;`arg`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象
`a.destroy(p)`| `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数
---
标准库`allocator`类及其算法|解释说明
|:-:|:-|
`allocator<T> a`| 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存
`a.allocate(n)`|分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象 
`a.deallocate(p,n)`|释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象;`p`必须是一个先前由`allocate`返回的指针，且`n`必须是`p`创建时所要求的大小。在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy`
`a.construct(p,args)`|`p`必须是一个类型为`T`的指针，指向一块原始内存;`arg`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象
`a.destroy(p)`|`p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数
---
`allocator`算法|解释说明
|:-:|:-|
`uninitialized_copy(b,e,b2)` |从迭代器`b`和`e`指出的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中。`b2`指向的内存必须足够大，能容纳输入序列中元素的拷贝
`uninitialized_copy_n(b,n,b2)`| 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中
`uninitialized_fill(b,e,t)` |在迭代器`b`和`e`指定的原始内存范围中创建对象，对象的值均为`t`的拷贝
`uninitialized_fill_n(b,n,t)` |从迭代器`b`指向的内存地址开始创建`n`个对象。`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象
```
这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。
```
---